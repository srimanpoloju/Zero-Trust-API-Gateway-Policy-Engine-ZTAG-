import { AuditRepository } from '../../src/database/AuditRepository';
import { db } from '../../src/database/index';
import { AuditLog } from '@ztag/shared';

// Mock the database module
jest.mock('../../src/database/index', () => ({
  db: {
    query: jest.fn(),
  },
}));

describe('Gateway AuditRepository Unit Tests', () => {
  const mockDbQuery = db.query as jest.Mock;

  beforeEach(() => {
    mockDbQuery.mockReset();
  });

  const mockAuditLogInput: Omit<AuditLog, 'id' | 'timestamp'> = {
    requestId: 'req-123',
    subject: { sub: 'user456', role: 'test-user' },
    resource: { service: 'test-service', path: '/api/test', method: 'GET' },
    decision: 'ALLOW',
    reason: 'Policy "test-policy" matched',
    policyId: 'policy-abc',
    latencyMs: 150,
    statusCode: 200,
    rateLimit: { key: 'test-key', limit: 10, remaining: 9, reset: 1678886400, windowSeconds: 60 },
    context: { ip: '192.168.1.1', userAgent: 'jest-test' },
    error: undefined,
  };

  const mockAuditLogOutput: AuditLog = {
    ...mockAuditLogInput,
    id: 'generated-uuid-123',
    timestamp: new Date().toISOString(), // This would be generated by DB
  };

  const dbRowFromAuditLog = (log: AuditLog) => ({
    id: log.id,
    request_id: log.requestId,
    timestamp: log.timestamp,
    subject: JSON.stringify(log.subject),
    resource: JSON.stringify(log.resource),
    decision: log.decision,
    reason: log.reason,
    policy_id: log.policyId,
    latency_ms: log.latencyMs,
    status_code: log.statusCode,
    rate_limit: JSON.stringify(log.rateLimit),
    context: JSON.stringify(log.context),
    error: log.error,
  });

  describe('create', () => {
    it('should create a new audit log entry', async () => {
      mockDbQuery.mockResolvedValueOnce({ rows: [dbRowFromAuditLog(mockAuditLogOutput)] });

      const createdLog = await AuditRepository.create(mockAuditLogInput);

      expect(mockDbQuery).toHaveBeenCalledTimes(1);
      expect(mockDbQuery).toHaveBeenCalledWith(expect.any(String), [
        mockAuditLogInput.requestId,
        JSON.stringify(mockAuditLogInput.subject),
        JSON.stringify(mockAuditLogInput.resource),
        mockAuditLogInput.decision,
        mockAuditLogInput.reason,
        mockAuditLogInput.policyId,
        mockAuditLogInput.latencyMs,
        mockAuditLogInput.statusCode,
        JSON.stringify(mockAuditLogInput.rateLimit),
        JSON.stringify(mockAuditLogInput.context),
        mockAuditLogInput.error,
      ]);
      expect(createdLog).toEqual(mockAuditLogOutput);
    });

    it('should handle audit log without rateLimit or error', async () => {
      const logWithoutOptional: Omit<AuditLog, 'id' | 'timestamp' | 'rateLimit' | 'error'> = {
        ...mockAuditLogInput,
        rateLimit: undefined,
        error: undefined,
      };
      const expectedOutput: AuditLog = {
        ...mockAuditLogOutput,
        rateLimit: undefined,
        error: undefined,
      };

      mockDbQuery.mockResolvedValueOnce({ rows: [dbRowFromAuditLog(expectedOutput)] });

      const createdLog = await AuditRepository.create(logWithoutOptional);

      expect(mockDbQuery).toHaveBeenCalledTimes(1);
      expect(mockDbQuery).toHaveBeenCalledWith(expect.any(String), [
        logWithoutOptional.requestId,
        JSON.stringify(logWithoutOptional.subject),
        JSON.stringify(logWithoutOptional.resource),
        logWithoutOptional.decision,
        logWithoutOptional.reason,
        logWithoutOptional.policyId,
        logWithoutOptional.latencyMs,
        logWithoutOptional.statusCode,
        null, // rateLimit is null in DB when undefined
        JSON.stringify(logWithoutOptional.context),
        undefined, // error is undefined
      ]);
      expect(createdLog).toEqual(expectedOutput);
    });
  });
});
